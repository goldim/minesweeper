{
  "version": 3,
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "define",
    "statics",
    "name",
    "config",
    "extend",
    "getClass",
    "__validateConfig",
    "iface",
    "$$extends",
    "properties",
    "$$properties",
    "members",
    "$$members",
    "events",
    "$$events",
    "$$type",
    "toString",
    "genericToString",
    "basename",
    "createNamespace",
    "Interface",
    "$$registry",
    "getByName",
    "isDefined",
    "undefined",
    "getTotalNumber",
    "objectGetLength",
    "flatten",
    "ifaces",
    "list",
    "concat",
    "i",
    "l",
    "length",
    "push",
    "apply",
    "__checkMembers",
    "object",
    "clazz",
    "wrap",
    "shouldThrow",
    "key",
    "isFunction",
    "isPropertyMethod",
    "__isPropertyMethod",
    "hasMemberFunction",
    "Error",
    "classname",
    "shouldWrapFunction",
    "util",
    "OOUtil",
    "hasInterface",
    "__wrapInterfaceMember",
    "methodName",
    "match",
    "propertyName",
    "firstLow",
    "getPropertyDefinition",
    "isBoolean",
    "check",
    "__checkProperties",
    "__checkEvents",
    "supportsEvent",
    "assertObject",
    "constructor",
    "assert",
    "prototype",
    "objectImplements",
    "classImplements",
    "has",
    "core",
    "Environment",
    "select",
    "origFunction",
    "functionName",
    "preCondition",
    "wrappedFunction",
    "arguments",
    "wrapper",
    "base",
    "__allowedKeys",
    "allowed",
    "maps",
    "indexOf",
    "a",
    "toUpperCase"
  ],
  "sources": [
    "C:/qx/minesweeper/node_modules/@qooxdoo/framework/source/class/qx/Interface.js"
  ],
  "sourcesContent": [
    "/* ************************************************************************\n\n   qooxdoo - the new era of web development\n\n   http://qooxdoo.org\n\n   Copyright:\n     2004-2008 1&1 Internet AG, Germany, http://www.1und1.de\n\n   License:\n     MIT: https://opensource.org/licenses/MIT\n     See the LICENSE file in the project's top-level directory for details.\n\n   Authors:\n     * Sebastian Werner (wpbasti)\n     * Andreas Ecker (ecker)\n\n************************************************************************ */\n\n/**\n * This class is used to define interfaces (similar to Java interfaces).\n *\n * See the description of the {@link #define} method how an interface is\n * defined.\n *\n * @require(qx.lang.normalize.Array)\n */\nqx.Bootstrap.define(\"qx.Interface\", {\n  statics: {\n    /*\n    ---------------------------------------------------------------------------\n       PUBLIC API\n    ---------------------------------------------------------------------------\n    */\n\n    /**\n     * Define a new interface. Interface definitions look much like class definitions.\n     *\n     * The main difference is that the bodies of functions defined in <code>members</code>\n     * and <code>statics</code> are called before the original function with the\n     * same arguments. This can be used to check the passed arguments. If the\n     * checks fail, an exception should be thrown. It is convenient to use the\n     * method defined in {@link qx.core.MAssert} to check the arguments.\n     *\n     * In the <code>build</code> version the checks are omitted.\n     *\n     * For properties only the names are required so the value of the properties\n     * can be empty maps.\n     *\n     * Example:\n     * <pre class='javascript'>\n     * qx.Interface.define(\"name\",\n     * {\n     *   extend: [SuperInterfaces],\n     *\n     *   statics:\n     *   {\n     *     PI : 3.14\n     *   },\n     *\n     *   properties: {\"color\": {}, \"name\": {} },\n     *\n     *   members:\n     *   {\n     *     meth1: function() {},\n     *     meth2: function(a, b) { this.assertArgumentsCount(arguments, 2, 2); },\n     *     meth3: function(c) { this.assertInterface(c.constructor, qx.some.Interface); }\n     *   },\n     *\n     *   events :\n     *   {\n     *     keydown : \"qx.event.type.KeySequence\"\n     *   }\n     * });\n     * </pre>\n     *\n     * @param name {String} name of the interface\n     * @param config {Map ? null} Interface definition structure. The configuration map has the following keys:\n     *   <table>\n     *     <tr><th>Name</th><th>Type</th><th>Description</th></tr>\n     *     <tr><th>extend</th><td>Interface |<br>Interface[]</td><td>Single interface or array of interfaces this interface inherits from.</td></tr>\n     *     <tr><th>members</th><td>Map</td><td>Map of members of the interface.</td></tr>\n     *     <tr><th>statics</th><td>Map</td><td>\n     *         Map of statics of the interface. The statics will not get copied into the target class.\n     *         This is the same behaviour as statics in mixins ({@link qx.Mixin#define}).\n     *     </td></tr>\n     *     <tr><th>properties</th><td>Map</td><td>Map of properties and their definitions.</td></tr>\n     *     <tr><th>events</th><td>Map</td><td>Map of event names and the corresponding event class name.</td></tr>\n     *   </table>\n     *\n     * @return {qx.Interface} The configured interface\n     */\n    define(name, config) {\n      if (config) {\n        // Normalize include\n        if (\n          config.extend &&\n          !(qx.Bootstrap.getClass(config.extend) === \"Array\")\n        ) {\n          config.extend = [config.extend];\n        }\n\n        // Validate incoming data\n        if (qx.core.Environment.get(\"qx.debug\")) {\n          this.__validateConfig(name, config);\n        }\n\n        // Create interface from statics\n        var iface = config.statics ? config.statics : {};\n\n        // Attach configuration\n        if (config.extend) {\n          iface.$$extends = config.extend;\n        }\n\n        if (config.properties) {\n          iface.$$properties = config.properties;\n        }\n\n        if (config.members) {\n          iface.$$members = config.members;\n        }\n\n        if (config.events) {\n          iface.$$events = config.events;\n        }\n      } else {\n        // Create empty interface\n        var iface = {};\n      }\n\n      // Add Basics\n      iface.$$type = \"Interface\";\n      iface.name = name;\n\n      // Attach toString\n      iface.toString = this.genericToString;\n\n      // Assign to namespace\n      iface.basename = qx.Bootstrap.createNamespace(name, iface);\n\n      // Add to registry\n      qx.Interface.$$registry[name] = iface;\n\n      // Return final interface\n      return iface;\n    },\n\n    /**\n     * Returns an interface by name\n     *\n     * @param name {String} class name to resolve\n     * @return {Class} the class\n     */\n    getByName(name) {\n      return this.$$registry[name];\n    },\n\n    /**\n     * Determine if interface exists\n     *\n     * @param name {String} Interface name to check\n     * @return {Boolean} true if interface exists\n     */\n    isDefined(name) {\n      return this.getByName(name) !== undefined;\n    },\n\n    /**\n     * Determine the number of interfaces which are defined\n     *\n     * @return {Number} the number of interfaces\n     */\n    getTotalNumber() {\n      return qx.Bootstrap.objectGetLength(this.$$registry);\n    },\n\n    /**\n     * Generates a list of all interfaces including their super interfaces\n     * (resolved recursively)\n     *\n     * @param ifaces {Interface[] ? []} List of interfaces to be resolved\n     * @return {Array} List of all interfaces\n     */\n    flatten(ifaces) {\n      if (!ifaces) {\n        return [];\n      }\n\n      // we need to create a copy and not to modify the existing array\n      var list = ifaces.concat();\n\n      for (var i = 0, l = ifaces.length; i < l; i++) {\n        if (ifaces[i].$$extends) {\n          list.push.apply(list, this.flatten(ifaces[i].$$extends));\n        }\n      }\n\n      return list;\n    },\n\n    /**\n     * Assert members\n     *\n     * @param object {qx.core.Object} The object, which contains the methods\n     * @param clazz {Class} class of the object\n     * @param iface {Interface} the interface to verify\n     * @param wrap {Boolean ? false} wrap functions required by interface to\n     *     check parameters etc.\n     * @param shouldThrow {Boolean} if <code>false</code>, the method\n     *   will return a boolean instead of throwing an exception\n     * @return {Boolean} <code>true</code> if all members are supported\n     */\n    __checkMembers(object, clazz, iface, wrap, shouldThrow) {\n      // Validate members\n      var members = iface.$$members;\n      if (members) {\n        for (var key in members) {\n          if (qx.Bootstrap.isFunction(members[key])) {\n            var isPropertyMethod = this.__isPropertyMethod(clazz, key);\n            var hasMemberFunction =\n              isPropertyMethod || qx.Bootstrap.isFunction(object[key]);\n\n            if (!hasMemberFunction) {\n              if (shouldThrow) {\n                throw new Error(\n                  'Implementation of method \"' +\n                    key +\n                    '\" is missing in class \"' +\n                    clazz.classname +\n                    '\" required by interface \"' +\n                    iface.name +\n                    '\"'\n                );\n              } else {\n                return false;\n              }\n            }\n\n            // Only wrap members if the interface was not been applied yet. This\n            // can easily be checked by the recursive hasInterface method.\n            var shouldWrapFunction =\n              wrap === true &&\n              !isPropertyMethod &&\n              !qx.util.OOUtil.hasInterface(clazz, iface);\n\n            if (shouldWrapFunction) {\n              object[key] = this.__wrapInterfaceMember(\n                iface,\n                object[key],\n                key,\n                members[key]\n              );\n            }\n          } else {\n            // Other members are not checked more detailed because of\n            // JavaScript's loose type handling\n            if (typeof object[key] === \"undefined\") {\n              if (shouldThrow) {\n                throw new Error(\n                  'Implementation of member \"' +\n                    key +\n                    '\" is missing in class \"' +\n                    clazz.classname +\n                    '\" required by interface \"' +\n                    iface.name +\n                    '\"'\n                );\n              } else {\n                return false;\n              }\n            }\n          }\n        }\n      }\n      if (!shouldThrow) {\n        return true;\n      }\n    },\n\n    /**\n     * Internal helper to detect if the method will be generated by the\n     * property system.\n     *\n     * @param clazz {Class} The current class.\n     * @param methodName {String} The name of the method.\n     *\n     * @return {Boolean} true, if the method will be generated by the property\n     *   system.\n     */\n    __isPropertyMethod(clazz, methodName) {\n      var match = methodName.match(/^(is|toggle|get|set|reset)(.*)$/);\n\n      if (!match) {\n        return false;\n      }\n\n      var propertyName = qx.Bootstrap.firstLow(match[2]);\n      var isPropertyMethod = qx.util.OOUtil.getPropertyDefinition(\n        clazz,\n        propertyName\n      );\n\n      if (!isPropertyMethod) {\n        return false;\n      }\n\n      var isBoolean = match[0] === \"is\" || match[0] === \"toggle\";\n      if (isBoolean) {\n        return (\n          qx.util.OOUtil.getPropertyDefinition(clazz, propertyName).check ===\n          \"Boolean\"\n        );\n      }\n\n      return true;\n    },\n\n    /**\n     * Assert properties\n     *\n     * @param clazz {Class} class to check interface for\n     * @param iface {Interface} the interface to verify\n     * @param shouldThrow {Boolean} if <code>false</code>, the method\n     *   will return a boolean instead of throwing an exception\n     * @return {Boolean} <code>true</code> if all properties are supported\n     */\n    __checkProperties(clazz, iface, shouldThrow) {\n      if (iface.$$properties) {\n        for (var key in iface.$$properties) {\n          if (!qx.util.OOUtil.getPropertyDefinition(clazz, key)) {\n            if (shouldThrow) {\n              throw new Error(\n                'The property \"' +\n                  key +\n                  '\" is not supported by Class \"' +\n                  clazz.classname +\n                  '\"!'\n              );\n            } else {\n              return false;\n            }\n          }\n        }\n      }\n      if (!shouldThrow) {\n        return true;\n      }\n    },\n\n    /**\n     * Assert events\n     *\n     * @param clazz {Class} class to check interface for\n     * @param iface {Interface} the interface to verify\n     * @param shouldThrow {Boolean} if <code>false</code>, the method\n     *   will return a boolean instead of throwing an exception\n     * @return {Boolean} <code>true</code> if all events are supported\n     */\n    __checkEvents(clazz, iface, shouldThrow) {\n      if (iface.$$events) {\n        for (var key in iface.$$events) {\n          if (!qx.util.OOUtil.supportsEvent(clazz, key)) {\n            if (shouldThrow) {\n              throw new Error(\n                'The event \"' +\n                  key +\n                  '\" is not supported by Class \"' +\n                  clazz.classname +\n                  '\"!'\n              );\n            } else {\n              return false;\n            }\n          }\n        }\n      }\n      if (!shouldThrow) {\n        return true;\n      }\n    },\n\n    /**\n     * Asserts that the given object implements all the methods defined in the\n     * interface. This method throws an exception if the object does not\n     * implement the interface.\n     *\n     *  @param object {qx.core.Object} Object to check interface for\n     *  @param iface {Interface} The interface to verify\n     */\n    assertObject(object, iface) {\n      var clazz = object.constructor;\n      this.__checkMembers(object, clazz, iface, false, true);\n      this.__checkProperties(clazz, iface, true);\n      this.__checkEvents(clazz, iface, true);\n\n      // Validate extends, recursive\n      var extend = iface.$$extends;\n      if (extend) {\n        for (var i = 0, l = extend.length; i < l; i++) {\n          this.assertObject(object, extend[i]);\n        }\n      }\n    },\n\n    /**\n     * Checks if an interface is implemented by a class\n     *\n     * @param clazz {Class} class to check interface for\n     * @param iface {Interface} the interface to verify\n     * @param wrap {Boolean ? false} wrap functions required by interface to\n     *     check parameters etc.\n     */\n    assert(clazz, iface, wrap) {\n      this.__checkMembers(clazz.prototype, clazz, iface, wrap, true);\n      this.__checkProperties(clazz, iface, true);\n      this.__checkEvents(clazz, iface, true);\n\n      // Validate extends, recursive\n      var extend = iface.$$extends;\n      if (extend) {\n        for (var i = 0, l = extend.length; i < l; i++) {\n          this.assert(clazz, extend[i], wrap);\n        }\n      }\n    },\n\n    /**\n     * Asserts that the given object implements all the methods defined in the\n     * interface.\n     *\n     *  @param object {qx.core.Object} Object to check interface for\n     *  @param iface {Interface} The interface to verify\n     * @return {Boolean} <code>true</code> if the objects implements the interface\n     */\n    objectImplements(object, iface) {\n      var clazz = object.constructor;\n      if (\n        !this.__checkMembers(object, clazz, iface) ||\n        !this.__checkProperties(clazz, iface) ||\n        !this.__checkEvents(clazz, iface)\n      ) {\n        return false;\n      }\n\n      // Validate extends, recursive\n      var extend = iface.$$extends;\n      if (extend) {\n        for (var i = 0, l = extend.length; i < l; i++) {\n          if (!this.objectImplements(object, extend[i])) {\n            return false;\n          }\n        }\n      }\n\n      return true;\n    },\n\n    /**\n     * Tests whether an interface is implemented by a class, without throwing an\n     * exception when it doesn't.\n     *\n     * @param clazz {Class} class to check interface for\n     * @param iface {Interface} the interface to verify\n     * @return {Boolean} <code>true</code> if interface is implemented\n     */\n    classImplements(clazz, iface) {\n      if (\n        !this.__checkMembers(clazz.prototype, clazz, iface) ||\n        !this.__checkProperties(clazz, iface) ||\n        !this.__checkEvents(clazz, iface)\n      ) {\n        return false;\n      }\n\n      // Validate extends, recursive\n      var extend = iface.$$extends;\n      if (extend) {\n        for (var i = 0, l = extend.length; i < l; i++) {\n          if (!this.has(clazz, extend[i])) {\n            return false;\n          }\n        }\n      }\n\n      return true;\n    },\n\n    /*\n    ---------------------------------------------------------------------------\n       PRIVATE/INTERNAL API\n    ---------------------------------------------------------------------------\n    */\n\n    /**\n     * This method will be attached to all interface to return\n     * a nice identifier for them.\n     *\n     * @internal\n     * @return {String} The interface identifier\n     */\n    genericToString() {\n      return \"[Interface \" + this.name + \"]\";\n    },\n\n    /** Registry of all defined interfaces */\n    $$registry: {},\n\n    /**\n     * Wrap a method with a precondition check.\n     *\n     * @signature function(iface, origFunction, functionName, preCondition)\n     * @param iface {String} Name of the interface, where the pre condition\n     *   was defined. (Used in error messages).\n     * @param origFunction {Function} function to wrap.\n     * @param functionName {String} name of the function. (Used in error messages).\n     * @param preCondition {Function}. This function gets called with the arguments of the\n     *   original function. If this function return true the original function is called.\n     *   Otherwise an exception is thrown.\n     * @return {Function} wrapped function\n     */\n    __wrapInterfaceMember: qx.core.Environment.select(\"qx.debug\", {\n      true(iface, origFunction, functionName, preCondition) {\n        function wrappedFunction() {\n          // call precondition\n          preCondition.apply(this, arguments);\n\n          // call original function\n          return origFunction.apply(this, arguments);\n        }\n\n        origFunction.wrapper = wrappedFunction;\n        if (origFunction.base !== undefined) {\n          if (wrappedFunction.base !== undefined) {\n            throw new Error(\"base is already defined for the wrapped function\");\n          }\n          wrappedFunction.base = origFunction.base;\n        }\n        return wrappedFunction;\n      },\n\n      default(iface, origFunction, functionName, preCondition) {}\n    }),\n\n    /** @type {Map} allowed keys in interface definition */\n    __allowedKeys: qx.core.Environment.select(\"qx.debug\", {\n      true: {\n        extend: \"object\", // Interface | Interface[]\n        statics: \"object\", // Map\n        members: \"object\", // Map\n        properties: \"object\", // Map\n        events: \"object\" // Map\n      },\n\n      default: null\n    }),\n\n    /**\n     * Validates incoming configuration and checks keys and values\n     *\n     * @signature function(name, config)\n     * @param name {String} The name of the class\n     * @param config {Map} Configuration map\n     */\n    __validateConfig: qx.core.Environment.select(\"qx.debug\", {\n      true(name, config) {\n        if (qx.core.Environment.get(\"qx.debug\")) {\n          // Validate keys\n          var allowed = this.__allowedKeys;\n\n          for (var key in config) {\n            if (allowed[key] === undefined) {\n              throw new Error(\n                'The configuration key \"' +\n                  key +\n                  '\" in class \"' +\n                  name +\n                  '\" is not allowed!'\n              );\n            }\n\n            if (config[key] == null) {\n              throw new Error(\n                \"Invalid key '\" +\n                  key +\n                  \"' in interface '\" +\n                  name +\n                  \"'! The value is undefined/null!\"\n              );\n            }\n\n            if (allowed[key] !== null && typeof config[key] !== allowed[key]) {\n              throw new Error(\n                'Invalid type of key \"' +\n                  key +\n                  '\" in interface \"' +\n                  name +\n                  '\"! The type of the key must be \"' +\n                  allowed[key] +\n                  '\"!'\n              );\n            }\n          }\n\n          // Validate maps\n          var maps = [\"statics\", \"members\", \"properties\", \"events\"];\n          for (var i = 0, l = maps.length; i < l; i++) {\n            var key = maps[i];\n\n            if (\n              config[key] !== undefined &&\n              ([\"Array\", \"RegExp\", \"Date\"].indexOf(\n                qx.Bootstrap.getClass(config[key])\n              ) != -1 ||\n                config[key].classname !== undefined)\n            ) {\n              throw new Error(\n                'Invalid key \"' +\n                  key +\n                  '\" in interface \"' +\n                  name +\n                  '\"! The value needs to be a map!'\n              );\n            }\n          }\n\n          // Validate extends\n          if (config.extend) {\n            for (var i = 0, a = config.extend, l = a.length; i < l; i++) {\n              if (a[i] == null) {\n                throw new Error(\n                  \"Extends of interfaces must be interfaces. The extend number '\" +\n                    i +\n                    1 +\n                    \"' in interface '\" +\n                    name +\n                    \"' is undefined/null!\"\n                );\n              }\n\n              if (a[i].$$type !== \"Interface\") {\n                throw new Error(\n                  \"Extends of interfaces must be interfaces. The extend number '\" +\n                    i +\n                    1 +\n                    \"' in interface '\" +\n                    name +\n                    \"' is not an interface!\"\n                );\n              }\n            }\n          }\n\n          // Validate statics\n          if (config.statics) {\n            for (var key in config.statics) {\n              if (key.toUpperCase() !== key) {\n                throw new Error(\n                  'Invalid key \"' +\n                    key +\n                    '\" in interface \"' +\n                    name +\n                    '\"! Static constants must be all uppercase.'\n                );\n              }\n\n              switch (typeof config.statics[key]) {\n                case \"boolean\":\n                case \"string\":\n                case \"number\":\n                  break;\n\n                default:\n                  throw new Error(\n                    'Invalid key \"' +\n                      key +\n                      '\" in interface \"' +\n                      name +\n                      '\"! Static constants must be all of a primitive type.'\n                  );\n              }\n            }\n          }\n        }\n      },\n\n      default(name, config) {}\n    })\n  }\n});\n"
  ],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;EAAAA,EAAE,CAACC,SAAH,CAAaC,oBAAb,CAAkCC,aAAlC;;EAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACAH,EAAE,CAACC,SAAH,CAAaG,MAAb,CAAoB,cAApB,EAAoC;IAClCC,OAAO,EAAE;MACP;AACJ;AACA;AACA;AACA;;MAEI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;MACID,MAhEO,kBAgEAE,IAhEA,EAgEMC,MAhEN,EAgEc;QACnB,IAAIA,MAAJ,EAAY;UACV;UACA,IACEA,MAAM,CAACC,MAAP,IACA,EAAER,EAAE,CAACC,SAAH,CAAaQ,QAAb,CAAsBF,MAAM,CAACC,MAA7B,MAAyC,OAA3C,CAFF,EAGE;YACAD,MAAM,CAACC,MAAP,GAAgB,CAACD,MAAM,CAACC,MAAR,CAAhB;UACD,CAPS,CASV;;;UACyC;YACvC,KAAKE,uBAAL,CAAsBJ,IAAtB,EAA4BC,MAA5B;UACD,CAZS,CAcV;;UACA,IAAII,KAAK,GAAGJ,MAAM,CAACF,OAAP,GAAiBE,MAAM,CAACF,OAAxB,GAAkC,EAA9C,CAfU,CAiBV;;UACA,IAAIE,MAAM,CAACC,MAAX,EAAmB;YACjBG,KAAK,CAACC,SAAN,GAAkBL,MAAM,CAACC,MAAzB;UACD;;UAED,IAAID,MAAM,CAACM,UAAX,EAAuB;YACrBF,KAAK,CAACG,YAAN,GAAqBP,MAAM,CAACM,UAA5B;UACD;;UAED,IAAIN,MAAM,CAACQ,OAAX,EAAoB;Y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"
}